
> 时间复杂度和空间复杂度是计算机算法的两个重要概念，用来衡量算法在处理输入数据时所需的时间和空间资源。时间复杂度描述了算法在处理数据时所需的时间量。通常使用大O记号表示，比如O(n)，O(n^2)，O(log n)，O(1)等。其中，n表示数据规模，n^2表示n的平方，log n表示以2为底的n的对数。时间复杂度的值越小，算法执行速度越快。因此，通常会尽量选择时间复杂度较小的算法。




> 空间复杂度描述了算法在处理数据时所需的空间量。同样使用大O记号表示，比如O(n)，O(n^2)，O(log n)，O(1)等。其中，n表示数据规模，n^2表示n的平方，log n表示以2为底的n的对数。空间复杂度的值越小，算法所需的内存资源越少。因此，通常会尽量选择空间复杂度较小的算法。



> 需要注意的是，时间复杂度和空间复杂度通常是互相矛盾的。例如，某个算法的时间复杂度很小，但是空间复杂度很大；反之亦然。因此，在实际应用中需要根据具体情况选择适合的算法。

```js
// 时间复杂度示例：
function sum(arr: number[]): number {
  let result = 0;
  for (let i = 0; i < arr.length; i++) {
    result += arr[i];
  }
  return result;
}
```
> 以上代码中，sum 函数接收一个数字数组 arr，然后使用一个循环遍历整个数组，并对数组元素进行累加，最终返回累加结果。在这个算法中，循环次数与输入数据的规模 n 相等，因此它的时间复杂度为 O(n)。



```js
// 空间复杂度示例：
function fibonacci(n: number): number {
  if (n < 2) {
    return n;
  }
  const arr: number[] = [0, 1];
  for (let i = 2; i <= n; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr[n];
}
```


> 以上代码中，fibonacci 函数接收一个数字 n，然后使用一个循环计算斐波那契数列的第 n 项，并返回结果。在这个算法中，使用了一个长度为 n+1 的数组 arr 存储中间结果，因此它的空间复杂度为 O(n)。